import logging

from django.conf import settings
from django.core.cache import cache

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response

from intuitlib.exceptions import AuthClientError

from libs.api.serializers.serializers import (
    SuccessErrorUrlRequestSerializer,
    URLSerializer,
)
from libs.quickbooks import default_quickbooks_client as quickbooks_client

from apps.core.api.views import BaseViewSet
from apps.users.api.permissions import IsAttorneyHasActiveSubscription

from .. import services
from . import serializers

logger = logging.getLogger('quickbooks')


CACHE_QB_AUTH_KEY = 'qb_auth'


class QuickBooksAuthorizationView(BaseViewSet):
    """View for different QuickBooks authorization operations.

    QuickBooks oAuth2 workflow: https://developer.intuit.com/app/developer/
    qbo/docs/develop/authentication-and-authorization/oauth-2.0

    """
    base_filter_backends = None
    pagination_class = None
    permissions_map = {
        'default': (IsAuthenticated, IsAttorneyHasActiveSubscription),
        'process_auth_callback': (AllowAny,)
    }

    @action(methods=['GET'], url_path='url', detail=False)
    def get_authorization_url(self, request, *args, **kwargs):
        """API method to get QuickBooks `authorization` url for attorney.

        It prepares `state_token` for a user and remembers success and error
        redirects in cache.

        """
        serializer = SuccessErrorUrlRequestSerializer(
            data=request.query_params
        )
        serializer.is_valid(raise_exception=True)

        client = quickbooks_client()
        auth_url = client.get_authorization_url()
        # remember random `state_token` generated by QuickBookClient to make
        # further user match in QB auth callback + remember `success_url` and
        # `error_url` to which user will be redirected on further auth steps
        cache.set(
            client.auth_client.state_token, {
                'user_id': request.user.id,
                'success_url': serializer.validated_data['success_url'],
                'error_url': serializer.validated_data['error_url']
            },
            60 * 60 * 24  # 1 day
        )
        return Response(
            data=URLSerializer({'url': auth_url}).data,
            status=status.HTTP_200_OK
        )

    @action(methods=['GET'], url_path='callback', detail=False)
    def process_auth_callback(self, request, *args, **kwargs):
        """API method which processes QuickBook oAuth2 callback.

        This callback is triggered by QuickBooks after user approves/denies
        app access request. So depending on user actions response can be:

            - successful -> continue auth and redirect user to `success_url`

            - error -> redirect user to `error_url`

            - absent `state_token` -> redirect user to
                `BASE_AUTH_ERROR_REDIRECT_URL`

        """
        data = request.query_params

        if 'error' in data:
            serializer = serializers.AccessDeniedSerializer(data=data)
            success = False
        else:
            serializer = serializers.AccessAllowedSerializer(data=data)
            success = True

        serializer.is_valid(raise_exception=True)
        data = serializer.validated_data
        state_info = cache.get(data['state'])

        # return user to corresponding page if there is an error
        if not state_info or not success:
            return_url = state_info['error_url'] if state_info \
                else settings.QUICKBOOKS['BASE_AUTH_ERROR_REDIRECT_URL']
            return Response(
                headers={'Location': return_url},
                status=status.HTTP_302_FOUND
            )

        # get user authorization tokens to perform future requests and
        # remember it in cache for 1 day - if user auth is successful
        return_url = state_info['success_url']
        try:
            auth_info = quickbooks_client().get_bearer_token(
                auth_code=data['code'],
                realm_id=data['realmId']
            )
            cache.set(
                state_info['user_id'],
                {CACHE_QB_AUTH_KEY: auth_info},
                60 * 60 * 24
            )
        except AuthClientError:
            return_url = state_info['error_url']

        return Response(
            headers={'Location': return_url},
            status=status.HTTP_302_FOUND
        )


class QuickBooksExportView(BaseViewSet):
    """View for different QuickBooks export operations."""
    base_filter_backends = None
    pagination_class = None
    permission_classes = IsAuthenticated, IsAttorneyHasActiveSubscription
    serializer_class = serializers.CustomerSerializer
    serializers_map = {
        'get_customers': serializers.CustomerSerializer,
        'export': serializers.ExportInvoiceSerializer,
    }

    @action(methods=['GET'], url_path='customers', detail=False)
    def get_customers(self, request, *args, **kwargs):
        """Get all available for export user `customers` from QuickBooks."""
        client = self._get_quickbooks_client(request)
        customers = [customer.to_dict() for customer in client.get_customers()]
        serializer = self.get_serializer_class()(customers, many=True)
        return Response(data=serializer.data, status=status.HTTP_200_OK)

    @action(methods=['POST'], url_path='invoice', detail=False)
    def export(self, request, *args, **kwargs):
        """Initiate invoice export to QuickBooks."""
        client = self._get_quickbooks_client(request)

        # validate export request params
        serializer = self.get_serializer(
            data=request.data, qb_api_client=client
        )
        serializer.is_valid(raise_exception=True)

        # export invoice to QuickBooks
        invoice = serializer.validated_data['invoice']
        customer = serializer.validated_data.get('customer')
        if not customer:
            customer = services.create_customer(invoice.matter.client, client)
        services.create_or_update_invoice(invoice, customer, client)

        return Response(status=status.HTTP_200_OK)

    def _get_quickbooks_client(self, request):
        """Shortcut to get initialized QuickBooks client."""
        auth_tokens = cache.get(request.user.id, {}).get(CACHE_QB_AUTH_KEY, {})
        return quickbooks_client(**auth_tokens, user=request.user)
